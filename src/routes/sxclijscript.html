<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sxclijscript - Optimized SVC Version (Real-Time Input)</title>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: sans-serif;
    }

    #left-panel,
    #terminal-container {
      padding: 10px;
      box-sizing: border-box;
    }

    #left-panel {
      width: 40%;
      display: flex;
      flex-direction: column;
    }

    #terminal-container {
      width: 60%;
      display: flex;
      flex-direction: column;
    }

    #terminal {
      background-color: #000;
      color: #0f0;
      font-family: monospace;
      padding: 10px;
      flex-grow: 1;
      overflow-y: auto;
      border: 2px solid #333;
      white-space: pre-wrap;
    }

    #codeInput {
      width: 100%;
      flex-grow: 1;
      font-family: monospace;
      padding: 5px;
      box-sizing: border-box;
      resize: none;
      margin-bottom: 10px;
    }

    #button-container {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .button {
      padding: 10px 20px;
      font-size: 1em;
    }
  </style>
</head>

<body>
  <div id="left-panel">
    <div id="button-container">
      <button id="runButton" class="button">Run</button>
    </div>
    <textarea id="codeInput" placeholder="Enter your sxclijscript code here">
main()
eternal_sleep()
fn read() (
    loop (
        svc(0)
        if(*4 == 0) (
            break
        )
        else (
            4 = *4 + 1
            svc(1)
        )
    )
)
fn main() (
    loop (
        read()
    )
)
fn eternal_sleep() (
    loop (
    )
)
    </textarea>
  </div>
  <div id="terminal-container">
    <div id="terminal"></div>
  </div>
  <script>

    const STACK_SZ = 1024;
    const MEM_SZ = 1 << 16;
    const GLOB_SZ = 1 << 8;
    const STK_SZ = 1 << 10;
    const rawMode = true;

    let inputQueue = [];

    const OP = Object.freeze({
      NULL: 0,
      NOP: 1,
      PUSH_CONST: 2,
      PUSH_VARADDR: 3,
      TEST01: 4,
      TEST02: 5,
      TEST03: 6,
      GLOBAL_GET: 7,
      GLOBAL_SET: 8,
      CALL: 9,
      RETURN: 10,
      JMP: 11,
      JZE: 12,
      OR: 13,
      AND: 14,
      EQ: 15,
      NE: 16,
      LT: 17,
      GT: 18,
      ADD: 19,
      SUB: 20,
      MUL: 21,
      DIV: 22,
      MOD: 23,
      SVC: 24,
      LABEL: 25,
      LABEL_FNEND: 26,
    });

    const GLOBAL = Object.freeze({
      NULL: 0,
      IP: 1,
      SP: 2,
      BP: 3,
      IO: 4,
    });

    const tokenEqStr = (token, str) => token && token.text === str;
    const isNum = (token) => token && /^-?\d+$/.test(token.text);
    const tokenToInt = (token) => parseInt(token.text, 10);
    const pushNode = (nodes, op, token, val) => nodes.push({ op, token, val });

    const tokenize = (src) => {
      const tokens = [];
      let i = 0;
      while (i < src.length) {
        const ch = src[i];
        if (" \n\t\r".includes(ch)) { i++; continue; }
        if ("(),.*&".includes(ch)) { tokens.push({ text: ch }); i++; continue; }
        if ((ch === "=" || ch === "!" || ch === "<" || ch === ">") &&
          src[i + 1] === "=") {
          tokens.push({ text: ch + "=" });
          i += 2; continue;
        }
        if ((ch === "&" && src[i + 1] === "&") ||
          (ch === "|" && src[i + 1] === "|")) {
          tokens.push({ text: ch + src[i + 1] });
          i += 2; continue;
        }
        let start = i;
        while (i < src.length && !" \n\t\r(),.*&".includes(src[i])) { i++; }
        tokens.push({ text: src.slice(start, i) });
      }
      return tokens;
    };

    const parsePrimary = (state, tokens, nodes, labels, labBreak, labCont) => {
      if (tokenEqStr(tokens[state.i], "(")) {
        state.i++;
        while (!tokenEqStr(tokens[state.i], ")")) {
          parseExpr(state, tokens, nodes, labels, labBreak, labCont);
          if (tokenEqStr(tokens[state.i], ",")) { state.i++; }
        }
        state.i++;
      } else if (isNum(tokens[state.i])) {
        pushNode(nodes, OP.PUSH_CONST, tokens[state.i], 0);
        state.i++;
      } else {
        pushNode(nodes, OP.PUSH_VARADDR, tokens[state.i], 0);
        pushNode(nodes, OP.GLOBAL_GET, null, 0);
        state.i++;
      }
    };
    const parsePostfix = (state, tokens, nodes, labels, labBreak, labCont) => {
      const start = tokens[state.i];
      if (tokens[state.i + 1] && tokenEqStr(tokens[state.i + 1], "(")) {
        state.i++;
        parsePrimary(state, tokens, nodes, labels, labBreak, labCont);
        if (tokenEqStr(start, "return")) {
          pushNode(nodes, OP.RETURN, null, 0);
        } else if (tokenEqStr(start, "svc")) {
          pushNode(nodes, OP.SVC, null, 0);
        } else {
          pushNode(nodes, OP.CALL, start, 0);
        }
      } else {
        parsePrimary(state, tokens, nodes, labels, labBreak, labCont);
      }
    };
    const parseUnary = (state, tokens, nodes, labels, labBreak, labCont) => {
      if (tokenEqStr(tokens[state.i], "&")) {
        state.i++;
        pushNode(nodes, OP.PUSH_VARADDR, tokens[state.i], 0);
        state.i++;
      } else if (tokenEqStr(tokens[state.i], "*")) {
        state.i++;
        parsePostfix(state, tokens, nodes, labels, labBreak, labCont);
        pushNode(nodes, OP.GLOBAL_GET, null, 0);
      } else {
        parsePostfix(state, tokens, nodes, labels, labBreak, labCont);
      }
    };
    const parseMul = (state, tokens, nodes, labels, labBreak, labCont) => {
      parseUnary(state, tokens, nodes, labels, labBreak, labCont);
      while (true) {
        if (tokenEqStr(tokens[state.i], "*")) {
          state.i++;
          parseUnary(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.MUL, null, 0);
        } else if (tokenEqStr(tokens[state.i], "/")) {
          state.i++;
          parseUnary(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.DIV, null, 0);
        } else if (tokenEqStr(tokens[state.i], "%")) {
          state.i++;
          parseUnary(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.MOD, null, 0);
        } else { break; }
      }
    };
    const parseAdd = (state, tokens, nodes, labels, labBreak, labCont) => {
      parseMul(state, tokens, nodes, labels, labBreak, labCont);
      while (true) {
        if (tokenEqStr(tokens[state.i], "+")) {
          state.i++;
          parseMul(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.ADD, null, 0);
        } else if (tokenEqStr(tokens[state.i], "-")) {
          state.i++;
          parseMul(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.SUB, null, 0);
        } else { break; }
      }
    };
    const parseRel = (state, tokens, nodes, labels, labBreak, labCont) => {
      parseAdd(state, tokens, nodes, labels, labBreak, labCont);
      while (true) {
        if (tokenEqStr(tokens[state.i], "<")) {
          state.i++;
          parseAdd(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.LT, null, 0);
        } else if (tokenEqStr(tokens[state.i], ">")) {
          state.i++;
          parseAdd(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.GT, null, 0);
        } else { break; }
      }
    };
    const parseEq = (state, tokens, nodes, labels, labBreak, labCont) => {
      parseRel(state, tokens, nodes, labels, labBreak, labCont);
      while (true) {
        if (tokenEqStr(tokens[state.i], "==")) {
          state.i++;
          parseRel(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.EQ, null, 0);
        } else if (tokenEqStr(tokens[state.i], "!=")) {
          state.i++;
          parseRel(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.NE, null, 0);
        } else { break; }
      }
    };
    const parseAnd = (state, tokens, nodes, labels, labBreak, labCont) => {
      parseEq(state, tokens, nodes, labels, labBreak, labCont);
      while (tokenEqStr(tokens[state.i], "&") &&
        tokens[state.i + 1] &&
        tokenEqStr(tokens[state.i + 1], "&")) {
        state.i += 2;
        parseEq(state, tokens, nodes, labels, labBreak, labCont);
        pushNode(nodes, OP.AND, null, 0);
      }
    };
    const parseOr = (state, tokens, nodes, labels, labBreak, labCont) => {
      parseAnd(state, tokens, nodes, labels, labBreak, labCont);
      while (tokenEqStr(tokens[state.i], "||")) {
        state.i++;
        parseAnd(state, tokens, nodes, labels, labBreak, labCont);
        pushNode(nodes, OP.OR, null, 0);
      }
    };
    const parseAssign = (state, tokens, nodes, labels, labBreak, labCont) => {
      parseOr(state, tokens, nodes, labels, labBreak, labCont);
      while (tokenEqStr(tokens[state.i], "=")) {
        state.i++;
        parseOr(state, tokens, nodes, labels, labBreak, labCont);
        pushNode(nodes, OP.GLOBAL_SET, null, 0);
      }
    };
    const parseExpr = (state, tokens, nodes, labels, labBreak, labCont) => {
      if (tokenEqStr(tokens[state.i], "if")) {
        const lab_if = labels.length;
        labels.push({ token: null, arg_size: 0, inst_index: -1 });
        const lab_else = labels.length;
        labels.push({ token: null, arg_size: 0, inst_index: -1 });
        state.i++;
        parseExpr(state, tokens, nodes, labels, labBreak, labCont);
        pushNode(nodes, OP.JZE, null, lab_if);
        parseExpr(state, tokens, nodes, labels, labBreak, labCont);
        if (tokenEqStr(tokens[state.i], "else")) {
          state.i++;
          pushNode(nodes, OP.JMP, null, lab_else);
          pushNode(nodes, OP.LABEL, null, lab_if);
          parseExpr(state, tokens, nodes, labels, labBreak, labCont);
          pushNode(nodes, OP.LABEL, null, lab_else);
        } else {
          pushNode(nodes, OP.LABEL, null, lab_if);
        }
      } else if (tokenEqStr(tokens[state.i], "loop")) {
        const lab_start = labels.length;
        labels.push({ token: null, arg_size: 0, inst_index: -1 });
        const lab_end = labels.length;
        labels.push({ token: null, arg_size: 0, inst_index: -1 });
        state.i++;
        pushNode(nodes, OP.LABEL, null, lab_start);
        parseExpr(state, tokens, nodes, labels, lab_end, lab_start);
        pushNode(nodes, OP.JMP, null, lab_start);
        pushNode(nodes, OP.LABEL, null, lab_end);
      } else if (tokenEqStr(tokens[state.i], "break")) {
        state.i++;
        pushNode(nodes, OP.JMP, null, labBreak);
      } else if (tokenEqStr(tokens[state.i], "continue")) {
        state.i++;
        pushNode(nodes, OP.JMP, null, labCont);
      } else if (tokenEqStr(tokens[state.i], "fn")) {
        const lab_fn = labels.length;
        let arg_size = 0;
        state.i++;
        labels[lab_fn] = { token: tokens[state.i], arg_size: 0, inst_index: -1 };
        state.i += 2;
        while (!tokenEqStr(tokens[state.i], ")")) {
          pushNode(nodes, OP.PUSH_VARADDR, tokens[state.i], 0);
          state.i++;
          arg_size++;
          if (tokenEqStr(tokens[state.i], ",")) { state.i++; }
        }
        const arg_itr = nodes[nodes.length - 1];
        for (let i = 0; i < arg_size; i++) { arg_itr.val = -4 - i; }
        state.i++;
        pushNode(nodes, OP.LABEL, null, lab_fn);
        pushNode(nodes, OP.PUSH_VARADDR, null, -2);
        pushNode(nodes, OP.PUSH_VARADDR, null, -2);
        pushNode(nodes, OP.GLOBAL_GET, null, 0);
        pushNode(nodes, OP.PUSH_CONST, null, arg_size);
        pushNode(nodes, OP.SUB, null, 0);
        pushNode(nodes, OP.GLOBAL_SET, null, 0);
        parseExpr(state, tokens, nodes, labels, labBreak, labCont);
        pushNode(nodes, OP.RETURN, null, 0);
        pushNode(nodes, OP.LABEL_FNEND, null, 0);
      } else {
        parseAssign(state, tokens, nodes, labels, labBreak, labCont);
      }
    };
    const parseTokens = (tokens, nodes, labels) => {
      const state = { i: 0 };
      while (state.i < tokens.length) {
        parseExpr(state, tokens, nodes, labels, -1, -1);
      }
    };

    const analyzePush = (nodes, locals, offsets) => {
      let off = 0;
      let localCount = 0;
      for (const n of nodes) {
        if (n.op === OP.LABEL_FNEND) { off = 0; localCount = 0; continue; }
        if (!n.token) continue;
        if (n.op === OP.PUSH_CONST) {
          n.val = tokenToInt(n.token);
        } else if (n.op === OP.PUSH_VARADDR) {
          let found = false;
          for (let i = 0; i < localCount; i++) {
            if (locals[i] && locals[i].text === n.token.text) {
              n.val = offsets[i]; found = true; break;
            }
          }
          if (!found) {
            locals[localCount] = n.token;
            offsets[localCount] = n.val !== 0 ? n.val : off;
            n.val = off; off++; localCount++;
          }
        }
      }
    };
    const findLabel = (labels, token) => {
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].token && labels[i].token.text === token.text) { return i; }
      }
      return -1;
    };
    const toInstructions = (mem, nodes, labels) => {
      let iptr = GLOB_SZ;
      for (const n of nodes) {
        if (n.op === OP.LABEL) {
          labels[n.val].inst_index = iptr;
        } else if (n.op === OP.PUSH_CONST || n.op === OP.PUSH_VARADDR) {
          mem[iptr++] = { op: n.op };
          mem[iptr++] = { val: n.val };
        } else if (n.op === OP.JMP || n.op === OP.JZE) {
          mem[iptr++] = { op: n.op };
          mem[iptr++] = { val: n.val };
        } else if (n.op === OP.CALL) {
          mem[iptr++] = { op: n.op };
          mem[iptr++] = { val: findLabel(labels, n.token) };
        } else if (n.op === OP.NOP) {
          continue;
        } else {
          mem[iptr++] = { op: n.op };
        }
      }
      mem[GLOBAL.IP] = { val: GLOB_SZ };
      mem[GLOBAL.BP] = { val: iptr };
      mem[GLOBAL.SP] = { val: iptr + STK_SZ };
      mem[iptr] = { op: OP.NULL };
    };
    const analyzeScript = (mem, nodes, locals, offsets, labels) => {
      analyzePush(nodes, locals, offsets);
      toInstructions(mem, nodes, labels);
    };
    const linkInstructions = (mem, labels) => {
      let i = GLOB_SZ;
      while (i < mem.length && mem[i]) {
        if (mem[i].op === OP.JMP ||
          mem[i].op === OP.JZE ||
          mem[i].op === OP.CALL) {
          i++;
          mem[i].val = labels[mem[i].val].inst_index;
        } else if (mem[i].op === OP.PUSH_CONST ||
          mem[i].op === OP.PUSH_VARADDR) {
          i += 2;
        } else {
          i++;
        }
      }
    };

    const outMemory = (mem) => {
      let output = "";
      for (let i = 1; i < 200; i++) {
        output += mem[i] && mem[i].val !== undefined ? mem[i].val + "\n" : "0\n";
      }
    };

    async function executeInstruction(mem) {
      let a1;
      let ip = mem[GLOBAL.IP].val;
      const instr = mem[ip];
      switch (instr.op) {
        case OP.NOP:
          break;
        case OP.PUSH_CONST:
          mem[GLOBAL.IP].val++;
          mem[mem[GLOBAL.SP].val++] = { val: mem[mem[GLOBAL.IP].val].val };
          break;
        case OP.PUSH_VARADDR:
          mem[GLOBAL.IP].val++;
          mem[mem[GLOBAL.SP].val++] = {
            val: mem[GLOBAL.BP].val + mem[mem[GLOBAL.IP].val].val,
          };
          break;
        case OP.GLOBAL_GET: {
          const addr = mem[mem[GLOBAL.SP].val - 1].val;
          mem[mem[GLOBAL.SP].val - 1] = { val: mem[addr] ? mem[addr].val : 0 };
          break;
        }
        case OP.GLOBAL_SET: {
          const addr2 = mem[mem[GLOBAL.SP].val - 2].val;
          mem[addr2] = { val: mem[mem[GLOBAL.SP].val - 1].val };
          mem[GLOBAL.SP].val -= 2;
          break;
        }
        case OP.CALL:
          mem[mem[GLOBAL.SP].val++] = { val: mem[GLOBAL.IP].val + 1 };
          mem[mem[GLOBAL.SP].val++] = { val: mem[GLOBAL.SP].val };
          mem[mem[GLOBAL.SP].val++] = { val: mem[GLOBAL.BP].val };
          mem[GLOBAL.IP].val = mem[mem[GLOBAL.IP].val + 1].val - 1;
          mem[GLOBAL.BP].val = mem[GLOBAL.SP].val + 3;
          mem[GLOBAL.SP].val += STK_SZ;
          break;
        case OP.RETURN:
          a1 = mem[mem[GLOBAL.SP].val - 1].val;
          mem[GLOBAL.IP].val = mem[mem[GLOBAL.BP].val - 3].val;
          mem[GLOBAL.SP].val = mem[mem[GLOBAL.BP].val - 2].val;
          mem[GLOBAL.BP].val = mem[mem[GLOBAL.BP].val - 1].val;
          mem[mem[GLOBAL.SP].val++] = { val: a1 };
          break;
        case OP.JMP:
          mem[GLOBAL.IP].val = mem[mem[GLOBAL.IP].val + 1].val - 1;
          break;
        case OP.JZE:
          if (mem[mem[GLOBAL.SP].val - 1].val === 0) {
            mem[GLOBAL.IP].val = mem[mem[GLOBAL.IP].val + 1].val - 1;
          } else {
            mem[GLOBAL.IP].val += 1;
          }
          mem[GLOBAL.SP].val--;
          break;
        case OP.OR:
          mem[mem[GLOBAL.SP].val - 2].val |= mem[mem[GLOBAL.SP].val - 1].val;
          mem[GLOBAL.SP].val--;
          break;
        case OP.AND:
          mem[mem[GLOBAL.SP].val - 2].val &= mem[mem[GLOBAL.SP].val - 1].val;
          mem[GLOBAL.SP].val--;
          break;
        case OP.EQ:
          mem[mem[GLOBAL.SP].val - 2].val =
            mem[mem[GLOBAL.SP].val - 2].val === mem[mem[GLOBAL.SP].val - 1].val ? 1 : 0;
          mem[GLOBAL.SP].val--;
          break;
        case OP.NE:
          mem[mem[GLOBAL.SP].val - 2].val =
            mem[mem[GLOBAL.SP].val - 2].val !== mem[mem[GLOBAL.SP].val - 1].val ? 1 : 0;
          mem[GLOBAL.SP].val--;
          break;
        case OP.LT:
          mem[mem[GLOBAL.SP].val - 2].val =
            mem[mem[GLOBAL.SP].val - 2].val < mem[mem[GLOBAL.SP].val - 1].val ? 1 : 0;
          mem[GLOBAL.SP].val--;
          break;
        case OP.GT:
          mem[mem[GLOBAL.SP].val - 2].val =
            mem[mem[GLOBAL.SP].val - 2].val > mem[mem[GLOBAL.SP].val - 1].val ? 1 : 0;
          mem[GLOBAL.SP].val--;
          break;
        case OP.ADD:
          mem[mem[GLOBAL.SP].val - 2].val += mem[mem[GLOBAL.SP].val - 1].val;
          mem[GLOBAL.SP].val--;
          break;
        case OP.SUB:
          mem[mem[GLOBAL.SP].val - 2].val -= mem[mem[GLOBAL.SP].val - 1].val;
          mem[GLOBAL.SP].val--;
          break;
        case OP.MUL:
          mem[mem[GLOBAL.SP].val - 2].val *= mem[mem[GLOBAL.SP].val - 1].val;
          mem[GLOBAL.SP].val--;
          break;
        case OP.DIV:
          mem[mem[GLOBAL.SP].val - 2].val = Math.floor(
            mem[mem[GLOBAL.SP].val - 2].val / mem[mem[GLOBAL.SP].val - 1].val
          );
          mem[GLOBAL.SP].val--;
          break;
        case OP.MOD:
          mem[mem[GLOBAL.SP].val - 2].val %= mem[mem[GLOBAL.SP].val - 1].val;
          mem[GLOBAL.SP].val--;
          break;
        case OP.SVC:
          a1 = mem[mem[GLOBAL.SP].val - 1].val;
          if (a1 === 0) {
            let inputChar = "";
            if (rawMode) {
              if (inputQueue.length === 0) {
                inputChar = await getNextInputChar();
              } else {
                inputChar = inputQueue.shift();
              }
            } else {
              inputChar = prompt("Enter a character:") || "";
            }
            mem[GLOBAL.IO] = { val: inputChar ? inputChar.charCodeAt(0) : 0 };
          } else if (a1 === 1) {
            const charCode = mem[GLOBAL.IO] ? mem[GLOBAL.IO].val : 0;
            printToTerminal(String.fromCharCode(charCode));
          } else if (a1 === 2) {

          }
          break;
        default:
          break;
      }
      mem[GLOBAL.IP].val++;
    }

    async function runScript(mem) {
      while (mem[mem[GLOBAL.IP].val].op !== OP.NULL) {
        await executeInstruction(mem);
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }
    const compile = (code) => {
      const tokens = tokenize(code);
      const nodes = [];
      const labels = [];
      parseTokens(tokens, nodes, labels);
      const locals = [];
      const offsets = [];
      const mem = new Array(MEM_SZ).fill(null);
      analyzeScript(mem, nodes, locals, offsets, labels);
      linkInstructions(mem, labels);

      return mem;
    };
    async function runVM(code) {
      const mem = compile(code);
      await runScript(mem);
    }

    const terminal = document.getElementById("terminal");
    const printToTerminal = (text) => {
      terminal.textContent += text + "\n";
      terminal.scrollTop = terminal.scrollHeight;
    };

    const codeInput = document.getElementById("codeInput");
    const runButton = document.getElementById("runButton");

    document.addEventListener("keydown", (e) => {
      if (e.key.length === 1) {
        inputQueue.push(e.key);
      }
    });
    runButton.addEventListener("click", async () => {
      terminal.textContent = "";
      const code = codeInput.value;
      await runVM(code);
    });

    function getNextInputChar() {
      return new Promise((resolve) => {
        const checkQueue = () => {
          if (inputQueue.length > 0) {
            resolve(inputQueue.shift());
          } else {
            setTimeout(checkQueue, 10);
          }
        };
        checkQueue();
      });
    }
  </script>
</body>

</html>